#!/usr/bin/env node

const { App } = require('@slack/bolt');
const { spawn } = require('child_process');
const fs = require('fs');
const path = require('path');

// Initialize Slack app
const app = new App({
  token: process.env.SLACK_BOT_TOKEN,
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  socketMode: true,
  appToken: process.env.SLACK_APP_TOKEN,
});

const PROJECT_ROOT = path.dirname(__dirname);

// Listen for @PM-agent mentions in #build-bot channel
app.message(/Build Bot/i, async ({ message, say, client }) => {
  console.log('🔔 PM-agent mentioned in Slack');
  
  // Check if in allowed channel (build-bot, build, bot, or any channel if BUILD_BOT_CHANNEL not set)
  const allowedChannel = process.env.BUILD_BOT_CHANNEL || 'build-bot';
  const channelInfo = await client.conversations.info({ channel: message.channel });
  
  // Allow if no restriction set, or if channel name contains the allowed pattern
  if (allowedChannel !== '*' && channelInfo.channel.name && !channelInfo.channel.name.includes(allowedChannel.replace('#', ''))) {
    console.log(`🚫 Ignoring mention in #${channelInfo.channel.name} (only responding in channels containing "${allowedChannel}")`);
    return;
  }

  // Extract requirements from message
  const requirements = message.text.replace(/<@[^>]+>/g, '').trim();
  
  if (!requirements) {
    await say({
      text: "🤖 PM-agent here! Please provide the full requirement text for me to generate a spec.",
      thread_ts: message.ts
    });
    return;
  }

  // React to show processing
  await client.reactions.add({
    channel: message.channel,
    timestamp: message.ts,
    name: 'robot_face'
  });

  try {
    console.log('📋 Generating spec from Slack message...');
    
    // Generate spec using AutoGen
    const specContent = await generateSpecFromRequirements(requirements);
    
    // Save spec.md
    const specPath = path.join(PROJECT_ROOT, 'spec.md');
    fs.writeFileSync(specPath, specContent);
    
    // Upload spec as file to Slack thread
    await client.files.upload({
      channels: message.channel,
      thread_ts: message.ts,
      file: fs.createReadStream(specPath),
      filename: 'spec.md',
      title: 'Generated Product Specification',
      initial_comment: `✅ **Specification Generated Successfully!**

📋 **Next Steps:**
1. Review and edit the \`spec.md\` file as needed
2. Run: \`./devin/devin_run.sh --issue <issue-number> --open\`
3. Or run: \`./devin/devin_run.sh --spec "custom requirements"\`

🔧 **Quick Commands:**
• \`/devin-run --issue 1\` - Generate from GitHub issue
• \`/devin-run --spec\` - Generate from current spec.md
• \`/cost-check\` - Check current pipeline costs

Generated by AutoGen Build Bot + Scribe-agent`
    });

    // Update reaction to checkmark
    await client.reactions.remove({
      channel: message.channel,
      timestamp: message.ts,
      name: 'robot_face'
    });
    
    await client.reactions.add({
      channel: message.channel,
      timestamp: message.ts,
      name: 'white_check_mark'
    });

  } catch (error) {
    console.error('❌ Error generating spec:', error);
    
    await say({
      text: `❌ **Spec Generation Failed**\n\`\`\`\n${error.message}\n\`\`\`\n\n🔧 **Troubleshooting:**\n• Check if Ollama is running: \`ollama serve\`\n• Verify phi3:mini model: \`ollama list\`\n• Check pipeline status: \`./scripts/monitor_costs.sh\``,
      thread_ts: message.ts
    });

    // Update reaction to X
    await client.reactions.remove({
      channel: message.channel,
      timestamp: message.ts,
      name: 'robot_face'
    });
    
    await client.reactions.add({
      channel: message.channel,
      timestamp: message.ts,
      name: 'x'
    });
  }
});

// Slash command: /devin-run
app.command('/devin-run', async ({ command, ack, respond, client }) => {
  await ack();
  
  const args = command.text.trim().split(/\s+/);
  let issueId = '';
  let useSpec = false;
  
  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--issue' && args[i + 1]) {
      issueId = args[i + 1];
      i++;
    } else if (args[i] === '--spec') {
      useSpec = true;
    }
  }
  
  if (!issueId && !useSpec) {
    await respond({
      text: `❌ **Invalid Usage**\n\nUsage:\n• \`/devin-run --issue <number>\` - Generate from GitHub issue\n• \`/devin-run --spec\` - Generate from current spec.md\n\nExample: \`/devin-run --issue 1\``
    });
    return;
  }

  await respond({
    text: `🚀 **Devin Pipeline Starting...**\n\n${issueId ? `📋 Issue: #${issueId}` : '📄 Using: spec.md'}\n\n⏳ This will take ~15 minutes. I'll update you when complete.`
  });

  try {
    // Build devin command
    const devinCmd = ['./devin/devin_run.sh'];
    if (issueId) {
      devinCmd.push('--issue', issueId);
    }
    devinCmd.push('--open');

    console.log('🤖 Running Devin:', devinCmd.join(' '));
    
    // Execute devin script
    const devin = spawn(devinCmd[0], devinCmd.slice(1), {
      cwd: PROJECT_ROOT,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let output = '';
    let errorOutput = '';

    devin.stdout.on('data', (data) => {
      output += data.toString();
      console.log(data.toString());
    });

    devin.stderr.on('data', (data) => {
      errorOutput += data.toString();
      console.error(data.toString());
    });

    devin.on('close', async (code) => {
      if (code === 0) {
        // Extract PR URL from output
        const prUrlMatch = output.match(/Pull request created: (https:\/\/[^\s]+)/);
        const branchMatch = output.match(/Branch: (devin\/[^\s]+)/);
        
        await client.chat.postMessage({
          channel: command.channel_id,
          text: `✅ **Devin Completed Successfully!**\n\n🎯 **Results:**\n• Branch: \`${branchMatch ? branchMatch[1] : 'Unknown'}\`\n• ${prUrlMatch ? `PR: ${prUrlMatch[1]}` : 'PR creation may have failed'}\n\n🔄 **Next Steps:**\n1. Review the pull request\n2. Test locally: \`git checkout ${branchMatch ? branchMatch[1] : 'branch-name'} && npm run dev\`\n3. Run tests: \`npm test\`\n4. Approve and merge when ready\n\n💰 **Cost Check:** Run \`/cost-check\` to see usage`
        });
      } else {
        await client.chat.postMessage({
          channel: command.channel_id,
          text: `❌ **Devin Failed**\n\n\`\`\`\n${errorOutput || output}\n\`\`\`\n\n🔧 **Troubleshooting:**\n• Check pipeline status: \`./scripts/monitor_costs.sh\`\n• Verify kill switch: \`echo $HALT_PIPELINE\`\n• Check GitHub CLI: \`gh auth status\``
        });
      }
    });

  } catch (error) {
    console.error('❌ Error running Devin:', error);
    
    await client.chat.postMessage({
      channel: command.channel_id,
      text: `❌ **Devin Execution Failed**\n\n\`\`\`\n${error.message}\n\`\`\`\n\nPlease check the logs and try again.`
    });
  }
});

// Slash command: /cost-check
app.command('/cost-check', async ({ command, ack, respond }) => {
  await ack();
  
  try {
    console.log('💰 Checking costs via Slack...');
    
    const costCheck = spawn('./scripts/monitor_costs.sh', [], {
      cwd: PROJECT_ROOT,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let output = '';
    let errorOutput = '';

    costCheck.stdout.on('data', (data) => {
      output += data.toString();
    });

    costCheck.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });

    costCheck.on('close', (code) => {
      if (code === 0) {
        respond({
          text: `💰 **Cost Status**\n\n\`\`\`\n${output}\n\`\`\`\n\n📊 Run \`./scripts/monitor_costs.sh\` locally for detailed breakdown.`
        });
      } else {
        respond({
          text: `❌ **Cost Check Failed**\n\n\`\`\`\n${errorOutput || 'Unknown error'}\n\`\`\`\n\nPlease check the monitoring script.`
        });
      }
    });

  } catch (error) {
    console.error('❌ Error checking costs:', error);
    respond({
      text: `❌ **Error**: ${error.message}`
    });
  }
});

// Generate spec using AutoGen (similar to generate-spec.js but integrated)
async function generateSpecFromRequirements(requirements) {
  return new Promise((resolve, reject) => {
    console.log('🤖 Starting AutoGen spec generation...');
    
    // Create temporary file with requirements
    const tempFile = path.join(PROJECT_ROOT, '.tmp-slack-requirements.txt');
    fs.writeFileSync(tempFile, requirements);
    
    // Run the robust generate-spec script
    const generateSpec = spawn('node', ['scripts/generate-spec.js', '--file', tempFile], {
      cwd: PROJECT_ROOT,
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let output = '';
    let errorOutput = '';

    generateSpec.stdout.on('data', (data) => {
      output += data.toString();
      console.log(data.toString());
    });

    generateSpec.stderr.on('data', (data) => {
      errorOutput += data.toString();
      console.error(data.toString());
    });

    generateSpec.on('close', (code) => {
      // Cleanup temp file
      try {
        fs.unlinkSync(tempFile);
      } catch (e) {
        // Ignore cleanup errors
      }

      if (code === 0) {
        // Read generated spec
        try {
          const specPath = path.join(PROJECT_ROOT, 'spec.md');
          const specContent = fs.readFileSync(specPath, 'utf8');
          resolve(specContent);
        } catch (error) {
          reject(new Error(`Failed to read generated spec: ${error.message}`));
        }
      } else {
        reject(new Error(`AutoGen failed: ${errorOutput || 'Unknown error'}`));
      }
    });
  });
}

// Start the Slack bot
(async () => {
  try {
    await app.start();
    console.log('⚡️ Slack bot is running!');
    console.log('🔔 Listening for @PM-agent mentions in #build-bot channels');
    console.log('💻 Available slash commands:');
    console.log('   • /devin-run --issue <number>');
    console.log('   • /devin-run --spec');
    console.log('   • /cost-check');
  } catch (error) {
    console.error('❌ Failed to start Slack bot:', error);
    process.exit(1);
  }
})();